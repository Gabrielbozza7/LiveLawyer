# Backend Architecture Description

The backend server (located at `LiveLawyerBackend` relative to the root of the repository) drives the logic that involves video calls, including starting them, connecting participants, and cleaning up with storing recordings.

## Default State

After the server starts, it waits for incoming socket connection and authentication-related requests without doing anything by default. All of the listeners that are created in the lifetime of the app, to my knowledge, all occur in `LiveLawyerBackend/src/index.ts`. For example, the backend event that is triggered when a client attempts to initiate a call is handled starting on line 46, and so what happens in that handler can be used to determine what code is running when a client attempts to initiate a call. For authentication, requests are made to `/signup` and `/login`, and those routes can be found starting at line 120. There are other routs visible around that code, but they don't correspond to completed functionality of the app yet (for example, `/contacts` is able to properly update contacts for a user, but the app doesn't use this route to do so properly yet). 

## The `CallCenter` Abstraction

The logic for dealing with the lifecycle of video calls is managed by the `CallCenter` class, whose body is defined at `LiveLawyerBackend/src/calls/CallCenter.ts`. A singleton instance of this class is instantiated in `index.ts` and is used until the server shuts down. Methods in this class can be called without pre-conditions for the most part because they are supposed to handle the edge cases. For example, just calling `CallCenter.connectClient()` without knowing if there are any observers available is safe because that method checks to see if there are aren't any available and handles that case. The main argument to most of these methods is the socket (`UserSocket`) that corresponds to the user who made the request that caused that method to be called (for example, the argument to `CallCenter.pullLawyer` is an observer: specifically, an observer trying to summon a lawyer).

When attempting to connect participants to a video call, there is a procedure in place that attempts to connect a participant again if an initial attempt to connect the participant fails. A mapping of socket IDs to video rooms is maintained for this. This works in some cases, notably when the network connection is broken between the server and a connecting user only for a few seconds, but it does not work reliably and does not cover all connection scenarios at this time.

The `CallCenter` maintains two queues, one for observers and one for lawyers. An observer or lawyer can join their queue by clicking the button to do so on the frontend website (at `/call`). Upon receiving such a request, the backend adds the socket of the user who sent the request to the appropriate queue. When a client attempts to make a call by clicking the big button on the app, the backend checks the size of the observer queue. If there are no observers in the queue, an indicator that the queue is empty is sent back to the user. If the queue is not empty, the first observer is removed from the queue, and the client and observer are joined to a new call. Similar logic occurs with lawyers: when an observer tries to summon a lawyer by pressing the corresponding button in the call, the lawyer queue is checked. If it's empty, an indicator that the queue is empty is sent back. If it isn't empty, the first lawyer is removed from the queue and joined to the existing call.

When any user tries to end the call, signals are sent to all participants for the call to end for everyone. This was based on our interpretation of handling calls, but it might not be the intended behavior. If this behavior is supposed to be changed, it can be changed at `CallCenter.handleHangUp()`. Note that there is no logic here to resend the signal if someone's connection is unstable as of now. If this situation occurs, those who weren't able to get the signal remain in the call with the functionality of the button for hanging up no longer working. This is an important future consideration because these video calls are configured to end one minute after the last participant leaves, and so a failure of the call to complete could result in spending more money than necessary. A forced termination of the call after a few seconds might be a good idea. Ending a call kicks off the logic for storing recordings, which will be covered in a later section.

The `CallCenter` also handles logic for dequeuing observers and lawyers when they press the button to stop receiving calls.

## The Socket Event Definitions

Up until this point, the protocol for communications between end users and the backend has been described loosely without exact details regarding which information gets actually passed. All of the socket events are described in `LiveLawyerLibrary/SocketEventDefinitions.ts`. The TypeScript compiler will generate errors at compile-time if there is an attempt to pass the wrong type of data as part of a socket request. This file of definitions is shared among the backend server, the app, and the frontend website, so most cases of passing the wrong kind of info should be caught before running any of the programs. Due to TypeScript's limitations, though, not all type errors can be caught because a function may return a different type than it claims to, and this not checked at runtime.

The events are annotated with comments that describe when they are supposed to run. You can search for these events throughout the repository to figure out where they are specifically fired and handled.

## The `TwilioManager` Abstraction

The code on the backend server that directly interfaces with Twilio is located in `LiveLawyerBackend/src/TwilioManager.ts`. Having most of the Twilio code in the same place should make migration to another video service less painful, however, not all of the Twilio logic is here (such as the logic for sending out the tokens). This is where calls are created and tokens are generated.

Twilio provides a JavaScript library (with optional TypeScript types that we do use) for interacting with their REST API. The library essentially acts like a 1:1 mapping from JavaScript to the API, with the URL paths being represented as objects all coming from a root object that is defined by the library. For example, in `TwilioManager.findOrCreateRoom()`, we create video rooms using `video.v1.rooms.create()` on the root object from the library, which corresponds to an equivalent POST request at `/v1/Rooms` to the video API. The naming is not always consistent (noting that the JS function is called `create` whereas the original HTTP version is just a POST to that endpoint), which makes looking up certain functionality a bit annoying at times. However, the body parameters that are described for a particular endpoint do appear to be consistent with the JavaScript object that you pass as an argument to the function. Consider the [documentation for the endpoint for creating a room](https://www.twilio.com/docs/video/api/rooms-resource#post-list-resource) and how we actually used the endpoint on lines 99-104 of `TwilioManager.ts`. The parameters we used do line up with the parameters in the documentation even though the name of the function is different. Sometimes there are examples that show the Node.js equivalent of a RESTful request (which there is in this case), which can be helpful.

Note that Twilio credentials are loaded from the `LiveLawyerBackend/.env` file, and warnings are shown if the server starts without the credentials being present. These credentials are bound to the library's root object for making requests.

Access to rooms is granted by tokens, which are generated on the backend server using the Twilio credentials. The algorithm for generating these tokens is asymmetric, so distributing these tokens to clients is (widely believed to be given the computing power available today) safe and is the only way to get participants to join a call. The actual distribution happens in the `CallCenter`, but the tokens are generated in the `TwilioManager` due to direct usage of the Twilio API. A grant is attached to each token to allow participants to do things in the call (such as share video).

Separately, the message that is supposed to be sent out to emergency contacts when a client makes a call does not actually get sent out. The message is successfully generated, and the generation is defined in `TwilioManager.notifyEmergencyContact()`. We weren't able to use a phone number from Twilio because obtaining one requires business/contact information verification, even for use with the free trial. This requirement can be encountered on the [dashboard](https://console.twilio.com/) by trying to claim a number. The verification prompt will be in the "Account Info" box.

## The `IdentityMap` Abstraction 

The `IdentityMap` class is used for mapping socket IDs for user IDs, located at `LiveLawyerBackend/src/IdentityMap.ts`. It is currently underused at the moment and does little more than actually map socket IDs for user IDs, however, it provides a template for socket authentication. The method `IdentityMap.register` contains an anonymous function whose return value can eventually be used to decide whether to authenticate a user, probably with the `userSecret` variable that is passed during connection attempts.

## The `ActiveRoom` and `RecordingProcessor` Abstractions

The `ActiveRoom` class, located at `LiveLawyerBackend/src/calls/ActiveRoom.ts`, is provided as a layer of abstraction on top of Twilio video rooms that is designed to integrate more nicely with our user ID and recording storage system. It is used to keep track of which sockets are associated with users that are participants in a video call. These are needed for sending the ending signal when the call ends to everyone in the call. This class, in `ActiveRoom.endCall()`, handles this signal sending and also starts the process of uploading the call's recordings using the `RecordingProcessor`.

The `RecordingProcessor` class is another singleton that is directly connected with the `TwilioManager` singleton. It uses Twilio credentials to download recordings from Twilio's recording storage. When a call ends, recordings to be downloaded are added to a download queue. While there are pending recordings in the queue, they are removed from the queue, downloaded, and added to the upload queue in sequence such that there is one download happening at a time. While there are downloaded recordings in the upload queue, they are removed from the queue, uploaded to Supabase, and locally deleted in sequence such that there is one upload happening at a time. This is not an ideal solution, as Twilio is able to dump recordings directly into AWS S3 buckets. However, when trying to set this up, we found out that this wouldn't work because the bucket has to an AWS S3 bucket and not just an S3-compliant bucket, which is what Supabase provides. If Twilio continues to be used, migration to an AWS S3 bucket and using Twilio to directly dump the recordings there would be a great way to save on bandwidth and compute resources.

It should be noted that the current way that recordings are found and added to the download queue on the `RecordingProcessor` is not ideal. After the call signals are sent out, the backend server waits five seconds and then polls the room for available recordings, adding them to the queue if they show up there, then discarding the room. This can be problematic if a recording doesn't finish being registered within those first five seconds, and there is no way to determine exactly how long this readiness process takes. This system should be replaced with [status callbacks](https://www.twilio.com/docs/video/api/status-callbacks#rooms-callback-events) in the future when there is a (semi-)permanent URL for Twilio to access.

## Notes on Deployment

Currently, the connections made between the backend and the app/website are using HTTP instead of HTTPS. For security reasons, it's important to use HTTPS instead for an actual deployment, but the current setup does not account for that transition. As part of refactoring, my suggestion would be to consolidate the `BACKEND_IP` and `BACKEND_PORT` environment variables in `LiveLawyerLibrary/.env` into a single variable such as `BACKEND_URL` which contains the protocol (so you could change between HTTP and HTTPS at will) as well as both the IP and the port. A similar change should be done with the `LiveLawyerApp/.env` file in this case until a solution is found that no longer requires the IP and port to be duplicated there. In `LiveLawyerLibrary/.env`, a full backend URL is generated, so another approach would be to add a `BACKEND_PROTOCOL` variable or something like that instead of deleting the existing variables. The URL could then be computed dynamically with less changes. Either way, there still are instances where "http://" is hardcoded with the usage of `BACKEND_IP` and `BACKEND_PORT` instead of just using `BACKEND_URL`, but at the very least, the existence of `BACKEND_URL` is a start. Usages of `BACKEND_IP`, `BACKEND_PORT`, and `http://` can be searched for in the repository to replace their usages with the usage of `BACKEND_URL`.

Another important area where URLs come into play is the backend server's definition of valid URLs for cross-origin resource sharing (CORS). These URLs are currently defined in `LiveLawyerBackend/src/index.ts` on line 25, and a socket request to the backend may only be made from one of these URLs *from the perspective of the client that is sending the request*. In other words, `localhost` as a CORS URL refers to the local device that is sending the request in the case of the app and refers to the URL of the frontend website in the case of the frontend website. That is why `localhost` is used with ports `3000` and `8081` as the current CORS URLs. For the app, `localhost` should remain intact because the "website" (the client rendered by React Native) is hosted on the device itself, but for the actual frontend website, the host should reflect the domain name that is eventually used for the website (because it wouldn't just be running on `localhost` like it has been in development so far). In any case, HTTPS should be used if the server is remote.

Currently, for the frontend website, there is no code to handle the user's decline of the browser's attempt to request permission to use the microphone and camera. On many browsers, this permission request is automatically declined if the site is both using HTTP (not HTTPS) and the host is not `localhost`. In Google Chrome, this automatic decline can be bypassed by setting the "Insecure origins treated as secure" flag to "Enabled" and adding the protocol-qualified URL to the site to the argument box, and flags can be configured at `chrome://flags`. Still, the website code does not try to re-request permission if this fails, so the user for now has to manually enable the permissions in the browser settings for the site to work on non-HTTPS, non-`localhost` sites. Of course, HTTPS should be used anyway, but it might be helpful to test if the services work like this before messing with TLS certificates to get HTTPS working. Re-requests for when the user declines permissions to microphone and camera access should not be too much work to implement and should ideally be inserted before the website even tries to send a socket request to enter a queue.

The app and website are known to work with the backend server hosted on a different machine if the proper flags are set as described previously, as this has been tested, but setting up HTTPS is an important security consideration.
